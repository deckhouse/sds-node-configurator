---
title: "Модуль sds-node-configurator: примеры использования"
description: Использование и примеры работы контроллера sds-node-configurator. Deckhouse Kubernetes Platform.
---

{{< alert level="warning" >}}
Работоспособность модуля гарантируется только при использовании стоковых ядер, поставляемых вместе с [поддерживаемыми дистрибутивами](https://deckhouse.ru/documentation/v1/supported_versions.html#linux).

Работоспособность модуля при использовании других ядер или дистрибутивов возможна, но не гарантируется.
{{< /alert >}}

Контроллер работает с двумя типами ресурсов:
* `BlockDevice`;
* `LVMVolumeGroup`.

## Работа с ресурсами `BlockDevice`

### Создание ресурса `BlockDevice`

Контроллер регулярно сканирует существующие девайсы на узле, и в случае, если девайс удовлетворяет всем необходимым
условиям со стороны контроллера, создается `custom resource` (CR) `BlockDevice` с уникальным именем, в котором отображена
полная и необходимая информация о соответствующем девайсе.

#### Требования контроллера к девайсу

* Не является drbd-устройством.
* Не является псевдодевайсом (то есть не loop device).
* Не является `Logical Volume`.
* Файловая система отсутствует или соответствует `LVM2_MEMBER`.
* У блок-девайса отсутствуют партиции.
* Размер блок-девайса больше 1 Gi.
* Если девайс — виртуальный диск, у него должен быть серийный номер.

Информацию из полученного ресурса контроллер будет использовать для своей дальнейшей работы с ресурсами `LVMVolumeGroup`.

### Обновление ресурса `BlockDevice`

Контроллер самостоятельно обновляет информацию в ресурсе, если состояние указанного в нем блок-девайса поменялось на узле.

### Удаление ресурса `BlockDevice`

Контроллер автоматически удалит ресурс, если указанный в нем блок-девайс стал недоступен. Удаление произойдёт только в следующих случаях:
* если ресурс был в статусе Consumable;
* если блок-девайс принадлежит `Volume Group`, у которой нет LVM-тега `storage.deckhouse.io/enabled=true` (эта `Volume Group` не управляется нашим контроллером).

> Контроллер выполняет вышеперечисленные виды работ автоматически и не требует вмешательства со стороны пользователя.

> В случае ручного удаления ресурса, он будет пересоздан контроллером.

## Работа с ресурсами `LVMVolumeGroup`

Ресурсы `BlockDevice` необходимы для создания и обновления ресурсов `LVMVolumeGroup`. 
На данный момент поддерживаются только локальные `Volume Group`.
`LVMVolumeGroup`-ресурсы предназначены для взаимодействия с `LVM Volume Group` на узлах и отображения актуальной информации об их состоянии.

### Создание ресурса `LVMVolumeGroup`

Ресурс `LVMVolumeGroup` может быть создан 2 способами:
* Автоматическое создание:
  * Контроллер автоматически сканирует информацию о существующих `LVM Volume Group` на узлах и создает ресурс в случае, если у `LVM Volume Group` имеется LVM-тег `storage.deckhouse.io/enabled=true` и соответствующий ей Kubernetes-ресурс отсутствует.
  * В этом случае контроллер самостоятельно заполнит все поля `Spec`-секции ресурса, кроме поля `thinPools`. Пользователю необходимо вручную добавить в `Spec` ресурса информацию о `Thin-pool`, имеющимся на узле, в случае, если он хочет, чтобы данный `Thin-pool` попал под управление контроллера.
* Пользовательское создание:
  * Пользователь вручную создает ресурс, заполняя только поля `metadata.name` и `spec`, в котором указывает желаемое состояние новой `Volume Group`.
  * Конфигурация, указанная пользователем, пройдет специальную валидацию на корректность.
  * После успешного прохождения валидации контроллер использует указанную конфигурацию, чтобы по ней создать указанную `LVM Volume Group` на узле и обновить пользовательский ресурс актуальной информацией о состоянии созданной `LVM Volume Group`.
  * Пример ресурса для создания локальной `LVM Volume Group` из нескольких `BlockDevice`:

    ```yaml
    apiVersion: storage.deckhouse.io/v1alpha1
    kind: LVMVolumeGroup
    metadata:
      name: "vg-0-on-node-0"
    spec:
      type: Local
      local:
        nodeName: "node-0"
      blockDeviceSelector:
        matchExpressions:
        - key: kubernetes.io/metadata.name
          operator: In
          values:
          - dev-07ad52cef2348996b72db262011f1b5f896bb68f
          - dev-e90e8915902bd6c371e59f89254c0fd644126da7
      actualVGNameOnTheNode: "vg-0"
    ```

    ```yaml
    apiVersion: storage.deckhouse.io/v1alpha1
    kind: LVMVolumeGroup
    metadata:
      name: "vg-0-on-node-0"
    spec:
      type: Local
      local:
        nodeName: "node-0"
      blockDeviceSelector:
        matchLabels:
          kubernetes.io/hostname: node-0
      actualVGNameOnTheNode: "vg-0"
    ```

  * Пример ресурса для создания локальной `LVM Volume Group` и `Thin-pool` на ней из нескольких `BlockDevice`:

    ```yaml
    apiVersion: storage.deckhouse.io/v1alpha1
    kind: LVMVolumeGroup
    metadata:
      name: "vg-0-on-node-0"
    spec:
      type: Local
      local:
        nodeName: "node-0"
      blockDeviceSelector:
        matchExpressions:
        - key: kubernetes.io/metadata.name
          operator: In
          values:
          - dev-07ad52cef2348996b72db262011f1b5f896bb68f
          - dev-e90e8915902bd6c371e59f89254c0fd644126da7
      actualVGNameOnTheNode: "vg-0"
      thinPools:
      - name: thin-1
        size: 250Gi
    ```

    ```yaml
    apiVersion: storage.deckhouse.io/v1alpha1
    kind: LVMVolumeGroup
    metadata:
      name: "vg-0-on-node-0"
    spec:
      type: Local
      local:
        nodeName: "node-0"
      blockDeviceSelector:
        matchLabels:
          kubernetes.io/hostname: node-0
      actualVGNameOnTheNode: "vg-0"
      thinPools:
      - name: thin-1
        size: 250Gi
    ```

  > Вы можете указать любые удобные для Вас селекторы для ресурсов `BlockDevice`. Так, например, Вы можете выбрать все девайсы на этом узле (используя, например, `matchLabels`), либо выбрать часть, дополнительно указав их имена (или иные другие параметры).
  > Обратите внимание, что поле `spec.local` является обязательным для типа `Local`. В случае расхождения имени в поле `spec.local.nodeName` и селекторах создание LVMVolumeGroup выполнено не будет.
  
  > **Внимание!** Все выбранные блок-девайсы должны принадлежать одному узлу для `LVMVolumeGroup` с типом 'Local'. 

### Обновление ресурса `LVMVolumeGroup`
Вы можете изменить желаемое состояние `VolumeGroup` или `thin pool` на узлах с помощью изменения поля `spec` соответствующего ресурса `LVMVolumeGroup`. Контроллер автоматически провалидирует новые данные и, в случае их валидного состояния, внесет необходимые изменения в сущности на узле.

Контроллер в автоматическом режиме обновляет поле `status` ресурса `LVMVolumeGroup`, отображая актуальные данные о соответствующей `LVM Volume Group` на узле.
Пользователю **не рекомендуется** собственноручно вносить изменения в поле `status`.

> Контроллер не обновляет поле `spec`, так как указанное поле отображает желаемое состояние `LVM Volume Group`. Пользователь может вносить изменения в поле `spec`, чтобы изменить состояние указанной в ресурсе `LVM Volume Group` на узле.

### Удаление ресурса `LVMVolumeGroup`

Контроллер автоматически удалит ресурс, если указанная в нем `Volume Group` стала недоступна по той или иной причине (например на узле были отключены все блочные устройства, из которых состояла `Volume Group`).

Пользователь может удалить `LVM Volume Group` с узла и связанные с ним `LVM Physical Volume`, выполнив команду на удаление ресурса `LVMVolumeGroup`.

```shell
kubectl delete lvg %lvg-name%
```

### Вывод ресурса `BlockDevice` из `LVMVolumeGroup` ресурса
Для того чтобы вывести `BlockDevice` ресурс из `LVMVolumeGroup` ресурса, необходимо либо изменить поле `spec.blockDeviceSelector` `LVMVolumeGroup` ресурса (добавить другие селекторы), либо изменить соответствующие лейблы у `BlockDevice` ресурса, чтобы они больше не попадали под селекторы `LVMVolumeGroup`. После этого вам необходимо вручную выполнить команды `pvmove`, `vgreduce`, и `pvremove` на узле.

> **Внимание!** Если удаляемый ресурс `LVMVolumeGroup` содержит `Logical Volume` (даже если это только `Thin-pool`, который указан в `spec`) пользователю необходимо самостоятельно удалить все `Logical Volume`, которые содержит удаляемая `Volume Group`. В противном случае ни ресурс, ни `Volume Group` удалены не будут.

> Пользователь может запретить удаление `LVMVolumeGroup` ресурса, повесив на ресурс специальную аннотацию `storage.deckhouse.io/deletion-protection`. При наличии данной аннотации контроллер не будет удалять ни ресурс, ни соответствующую `Volume Group` до тех пор, пока аннотация не будет снята с ресурса.

## Защита от утечек данных между томами

При удалении файлов операционная система не удаляет содержимое физически, а лишь помечает соответствующие блоки как «свободные». Если новый том получает физические блоки, ранее использовавшиеся другим томом, в них могут остаться данные предыдущего пользователя. 

Такое возможно, например, в таком случае:
  - пользователь №1 разместил файлы в томе, запрошенном из StorageClass 1 и на узле 1 (не важно, в режиме «Block» или «Filesystem»);
  - пользователь №1 удалил файлы и том;
  - физические блоки, которые он занимал, становятся «свободными», но не затертыми;
  - пользователь №2 запросил новый том из StorageClass 1 и на узле 1 в режиме «Block»;
  - есть риск, что часть или все блоки, ранее занимаемые пользователем №1, будут снова выделены пользователю №2;
  - в этом случае пользователь №2 имеет возможность восстановить данные пользователя №1.

### Thick-тома

Для предотвращения утечек через thick-тома предусмотрено два параметра `volumeCleanupMethod`.

#### Параметр `volumeCleanupMethod`

* `Disable` - не выполнять никаких дополнительных действий при удалении тома. Данные могут оказаться доступными следующему пользователю;

* `SinglePass` - том будет перезаписан случайными данными один раз перед удалением. Использовать эту опцию не рекомендуется для твердотельных накопителей, как она уменьшает ресурс накопителя.

* `ThreePass` - том будет перезаписан случайными данными три раза перед удалением. Использовать эту опцию не рекомендуется для твердотельных накопителей, как она уменьшает ресурс накопителя. 

* `Discard` - все блоки тома будут отмечены как свободные с использованием системного вызова `discard` перед удалением. Эта опция имеет смысл только для твердотельных накопителей.

Большинство современных твердотельных накопителей гарантирует, что помеченный `discard` блок при чтении не вернет предыдущие данные. Это делает опцию `Discard` самым эффективным способом предотвращения утечек при использовании твердотельных накопителей.
Однако очистка ячейки относительно долгая операция, поэтому выполняется устройством в фоне. К тому-же многие диски не могут очищать индивидуальные ячейки, а только группы - страницы. Из-за этого не все накопители гарантируют немедленную недоступность освобожденных данных. К тому-же не все накопители, гарантирующие это, держат обещание.
Если устройство не гарантирует Deterministic TRIM (DRAT), Deterministic Read Zero after TRIM (RZAT) и не является проверенным, то использовать его не рекомендуется.

<!-- #### Параметр `volumePreparationMethod`

* `Disable` - не выполнять никаких дополнительных действий перед использованием тома. Данные могут оказаться доступными следующему пользователю;
* `ZeroFill` - том будет заполнен нулями перед использованием. Эта опция имеет смысл для твердотельных накопителей, если устройство не гарантирует немедленную недоступность освобожденных данных на чтение после `discard` при удалении тома. -->



<!-- ##### `SinglePass`

Том будет перезаписан случайными данными один раз перед удалением. Эта опция имеет смысл для жестких дисков, так как они физически заменяют старые данные новыми и без физического доступа к диску старые данные не могут быть восстановлены. -->
<!-- Если записать новые данные в блочное устройство, то вычитать старые данные без специальных средств не получится. На жестком диске блоки располагаются в фиксированных областях диска. При записи в блочное устройство такого диска, данные на пластинах заменяются новыми. Поэтому для случая жесткого диска подходит `SinglePass` метод. -->

<!-- Эта опция имеет смысл для жестких дисков, так как они физически заменяют старые данные новыми и без физического доступа к диску старые данные не могут быть восстановлены; -->

<!-- #### Опция `ThreePass` -->

<!-- Том будет перезаписан случайными данными три раза перед удалением. Эта опция имеет смысл для жестких дисков, если есть риск, что жесткий диск будет физически доступен для восстановления данных с использованием спец средств. -->

<!-- Если есть риск, что жесткий диск будет физически доступен для восстановления данных с использованием спец средств, может появиться необходимость затирать данные несколько раз. Для этого предусмотрена опция `ThreePass`. -->

<!-- #### Опция `Discard` -->


<!-- Большинство современных накопителей гарантирует, что помеченный `discard` блок при чтении не вернет предыдущие данные. Это делает опцию `Discard` самым эффективным способом предотвращения утечек при использовании твердотельных накопителей.

Однако очистка ячейки относительно долгая операция, поэтому выполняется устройством в фоне. К тому-же многие диски не могут очищать индивидуальные ячейки, а только группы - страницы. Из-за этого не все накопители гарантируют немедленную недоступность освобожденных данных. К тому-же не все накопители, гарантирующие это, держат обещание.

Если устройство не гарантирует Deterministic TRIM (DRAT), Deterministic Read Zero after TRIM (RZAT) и не является проверенным, то рекомендуется использовать опцию `volumePreparationMethod`. -->

<!-- Для твердотельных накопителей в OS Linux предусмотрена команда `discard`. Она используется для отметки блока данных как свободного.  -->


<!-- Устройство балансирует использование ячеек (wear leveling), предпочтительно записывая данные в свободную ячейку с большим остаточным ресурсом. `discard` значительно увеличивает ресурс диска, увеличивая выбор свободных блоков при записи новых данных.



В твердотельных накопителях используется NAND флеш-память. Ячейки такой памяти нельзя переписать без полной очистки, к тому-же они имеют ограниченный ресурс циклов очистки-записи. Из-за этой особенности при модификации новые данные записываются в чистую ячейку, которая логически подменяет собой старую. Из-за этого данные старой ячейки могут оказаться доступными для извлечения с использованием спец-средств. Гарантировать удаление данных (SecureErase) могут только производители дисков через специальные утилиты. -->


### Thin-тома

В момент освобождения блока thin-тома через `discard` гостевой ОС, эта команда пересылается на устройство. В случае использования жесткого диска или проблем с поддержкой `discard` со стороны твердотельного накопителя, данные могут остаться на thin-pool до нового использования такого блока. Однако, мы не отдаем пользователям thin пул. Они могут получить только том из пула, а для Thin-томов производится зануление блока thin-pool при новом использовании, что предотвращает утечки между клиентами. Это гарантируется настройкой `thin_pool_zero=1` в LVM. 

<!-- ## Безопасность удаления данных

Для предотвращения утечки данных между виртуальными машинами через блочные устройства LVM необходимо учитывать, что удаление данных работает по-разному на жестких дисках и твердотельных накопителях. Это продиктовано различиями в принципах работы этих устройств.

Жесткий диск при записи данных в блок физически заменяет старые данные новыми. Твердотельный накопитель пишет новые данные в новый блок, а старый блок помечает для очистки. При этом блоки твердотельного накопителя имеют ограниченный ресурс циклов очистки/записи. Для продления срока службы твердотельных накопителей предусмотрена команда `discard`, которая помечает блок свободным напрямую, без записи новых данных.

Поэтому, для жестких дисков мы предусмотрели опцию `secureEraseForHDD`, которая задает процедуру очистки блоков при удалении логических томов. Опцию можно отредактировать перед удалением тома. Данная опция применима только к thick-томам. При этом мы всегда перед удалением тома отправляем команду `discard` на физическое устройство, чтобы пометить блоки этого тома свободными (если это не будет отключено в опции `secureEraseForHDD`).

> **Внимание!** Недоступность данных после `discard` зависит от физического устройства. Некоторые устройства могут отдавать старые данные, несмотря на то, что они помечены как свободные.

Опция `secureEraseForHDD` имеет следующие значения: 

* `Disable` - не выполнять никаких дополнительных действий при удалении тома (`discard` при этом тоже НЕ будет отправлен на физическое устройство);
* `SinglePass` - выполнить однопроходное затирание блоков случайными данными;
* `ThreePass` - выполнить трехпроходное затирание блоков случайными данными.

> **Внимание!** Не рекомендуется использовать опцию `secureEraseForHDD` для SSD, тк мы не проверяем, что устройство является HDD, поэтому опция `secureEraseForHDD` будет применена ко всем устройствам, на которых находится том, даже если это SSD. 


* Для жестких дисков добавлена опция `secureEraseForHDD`:
  * задает процедуру очистки блоков, удаляемых логических томов
  * нельзя включить для thin-томов
* Для твердотельных накопителей:
  * LVM пересылает `discard` с логических томов на физическое устройство (с какой версии?)
  * при удалении логических томов `discard` отправляется на все занятые этими томами блоки физического устройства
* Для thin-томов:
  * включена настройка LVM, гарантирующая вычитывание нулей из блоков и их областей, которые ещё не были записаны.
  * при освобождении блоков через `discard` логического тома, команда пересылается на физическое устройство
  * нельзя включить опцию `secureEraseForHDD` -->

<!-- * обычные тома:
  * `devices/issue_discards=1` для отправки `discard` на физическое устройство, когда блоки перестают использоваться LVM, например при удалении томов.
* thin-тома:
  * `allocation/thin_pool_discards="passdown"` для пересылки `discard` на устройство с thin-томов
  * `allocation/thin_pool_zero=1` для зануления блоков thin-томов при первом использовании -->
<!-- 
Для жестких дисков добавлена опция `secureEraseForHDD` в `LVMLogicalVolume` и `LocalStorageClass`, которая задает процедуру очистки блоков при удалении логических томов. Опцию можно отредактировать перед удалением тома. -->

<!-- > **Внимание!** Эту опцию нельзя включить для thin-томов.  -->

<!-- Для освобождаемых блоков вызывается только `discard`, который ничего не делает на жестком диске, а затирание нулями произойдет только когда блок будет снова использован. Данные пользователя всё это время будут оставаться на диске. Затереть данные в этом случае может только пользовательское приложение. Однако если есть снапшот, приложение не сможет затереть данные.

В результате:

* Для жестких дисков добавлена опция `secureEraseForHDD`:
  * задает процедуру очистки блоков, удаляемых логических томов
  * нельзя включить для thin-томов
* Для твердотельных накопителей:
  * LVM пересылает `discard` с логических томов на физическое устройство (с какой версии?)
  * при удалении логических томов `discard` отправляется на все занятые этими томами блоки физического устройства
* Для thin-томов:
  * включена настройка LVM, гарантирующая вычитывание нулей из блоков и их областей, которые ещё не были записаны.
  * при освобождении блоков через `discard` логического тома, команда пересылается на физическое устройство
  * нельзя включить опцию `secureEraseForHDD`

TODO: Подсветить:

* Не все твердотельные накопители дают гарантии чтения из освобожденных блоков. Будет ошибка?
* Очистка физических устройств при удалении из Volume Group?
* С какой версии LVM пересылает дискарды с логических томов? -->
